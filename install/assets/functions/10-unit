#!/command/with-contenv bash

unit_bootstrap_filesystem() {
    if [ ! -d "${UNIT_CONTROL_SOCKET_PATH}" ]; then
        mkdir -p "${UNIT_CONTROL_SOCKET_PATH}"
    fi
    if [ "$(stat -c %U "${UNIT_CONTROL_SOCKET_PATH}")" != "${UNIT_USER}" ] ; then silent chown "${UNIT_USER}":"${UNIT_GROUP}" "${UNIT_CONTROL_SOCKET_PATH}" ; fi

    if [ "${UNIT_LOG_TYPE,,}" = "file" ]; then
        if [ ! -d "${UNIT_LOG_PATH}" ]; then
            mkdir -p "${UNIT_LOG_PATH}"
        fi

        if [ "$(stat -c %U "${UNIT_LOG_PATH}")" != "${UNIT_USER}" ] ; then chown "${UNIT_USER}":"${UNIT_GROUP}" "${UNIT_LOG_PATH}" ; fi
        touch "${UNIT_LOG_PATH}"/"${UNIT_LOG_FILE}"
        chown -R "${UNIT_USER}":"${UNIT_GROUP}" "${UNIT_LOG_PATH}"/"${UNIT_LOG_FILE}"
    fi

    if [ "${UNIT_LOG_ACCESS_TYPE,,}" = "file" ]; then
        if [ "${UNIT_LOG_ACCESS_PATH}" != "${UNIT_LOG_PATH}" ] && [ "${UNIT_LOG_ACCESS_TYPE,,}" != "none" ]; then
            if [ ! -d "${UNIT_LOG_ACCESS_PATH}" ]; then
                mkdir -p "${UNIT_LOG_ACCESS_PATH}"
            fi

            if [ "$(stat -c %U "${UNIT_LOG_ACCESS_PATH}")" != "${UNIT_USER}" ] ; then chown "${UNIT_USER}":"${UNIT_GROUP}" "${UNIT_LOG_ACCESS_PATH}" ; fi
            touch "${UNIT_LOG_ACCESS_PATH}"/"${UNIT_LOG_ACCESS_FILE}"
            chown -R "${UNIT_USER}":"${UNIT_GROUP}" "${UNIT_LOG_ACCESSPATH}"/"${UNIT_LOG_ACCESS_FILE}"
        fi
    fi

    if [ ! -d "${UNIT_MODULE_PATH}" ]; then
        mkdir -p "${UNIT_MODULE_PATH}"
    fi
    if [ "$(stat -c %U "${UNIT_MODULE_PATH}")" != "${UNIT_USER}" ] ; then silent chown "${UNIT_USER}":"${UNIT_GROUP}" "${UNIT_MODULE_PATH}" ; fi

    if [ ! -d "${UNIT_STATE_PATH}" ]; then
        mkdir -p "${UNIT_STATE_PATH}"
    fi
    if [ "$(stat -c %U "${UNIT_STATE_PATH}")" != "${UNIT_USER}" ] ; then chown "${UNIT_USER}":"${UNIT_GROUP}" "${UNIT_STATE_PATH}" ; fi
}

unit_configure_instance() {
    _unit_configure_log_format() {
        print_debug "Updating logformat settings"
        case "${UNIT_LOG_TYPE}" in
            file)
                yq -iP '.access_log.path="'$(echo "${UNIT_LOG_ACCESS_PATH}"/"${UNIT_LOG_ACCESS_FILE}")'"' /etc/unit/snippets/logformat/${UNIT_LOG_ACCESS_FORMAT,,}.json -o json
                create_logrotate unit "${UNIT_LOG_ACCESS_PATH}"/"${UNIT_LOG_ACCESS_FILE}" unit "${UNIT_USER}" "${UNIT_GROUP}"
            ;;
        esac

        case "${UNIT_LOG_ACCESS_TYPE}" in
            console)
                yq -iP '.access_log.path="/dev/stdout"' /etc/unit/snippets/logformat/${UNIT_LOG_ACCESS_FORMAT,,}.json -o json
            ;;
            file)
                yq -iP '.access_log.path="'$(echo "${UNIT_LOG_ACCESS_PATH}"/"${UNIT_LOG_ACCESS_FILE}")'"' /etc/unit/snippets/logformat/${UNIT_LOG_ACCESS_FORMAT,,}.json -o json
                create_logrotate unit-access "${UNIT_LOG_ACCESS_PATH}"/"${UNIT_LOG_ACCESS_FILE}" unit-access-"${UNIT_LOG_ACCESS_FORMAT,,}" "${UNIT_USER}" "${UNIT_GROUP}"
            ;;
            none)
                yq -iP '.access_log.path="/dev/null"' /etc/unit/snippets/logformat/${UNIT_LOG_ACCESS_FORMAT,,}.json -o json
            ;;
        esac
    }

    _unit_configure_settings() {
        print_debug "Updating unit.json settings"
        yq -iP  '
                    .http.body_read_timeout = env(UNIT_TIMEOUT_BODY_READ) |
                    .http.header_read_timeout = env(UNIT_TIMEOUT_HEADER_READ) |
                    .http.idle_timeout = env(UNIT_TIMEOUT_IDLE) |
                    .http.send_timeout = env(UNIT_TIMEOUT_BODY_SEND) |
                    .http.max_body_size = env(UNIT_MAX_BODY_SIZE) |
                    .http.discard_unsafe_fields = env(UNIT_DISCARD_UNSAFE_FIELDS) |
                    .http.log_route = env(UNIT_LOG_ROUTES) |
                    .http.server_version = env(UNIT_ENABLE_SERVER_VERSION)
                ' /etc/unit/snippets/unit.json -o json
    }

    _unit_configure_log_format
    _unit_configure_settings

}

unit_configure_site_default() {
    if [ -z "${UNIT_SITE_ENABLED}" ] && [ ! -f "/etc/unit/sites.available/default.json" ] ; then
        cat <<EOF > /etc/unit/sites.available/default.json
{
  "listeners": {
    "${UNIT_LISTEN_IP}:${UNIT_LISTEN_PORT}": {
      "pass": "routes"
    }
  },
  "routes": [
    {
      "action": {
        "share": "${UNIT_WEBROOT}/$uri"
      }
    }
  ]
}
EOF
        # Not entirely working yet
        #yq -nP  '
        #            .listeners."'$(echo "${UNIT_LISTEN_IP}:${UNIT_LISTEN_PORT}")'".pass="routes" |
        #            .routes.action.share = "'$(echo "${UNIT_WEBROOT}")'/$uri"
        #        ' -o json > /etc/unit/sites.available/default.json
    fi
}


unit_create_sample_html() {
    if [ ! -f "${UNIT_WEBROOT}/index.html" ]; then
        print_notice "Creating sample index.html"
        mkdir -p "${UNIT_WEBROOT}"
        cat <<EOF >"${UNIT_WEBROOT}"/index.html
<html>
<title>Default Page</title>
<h2>Container is working</h2>
Congratulations! Your ${IMAGE_NAME} image is working. You are seeing this because you don't have an index.html file in your ${UNIT_WEBROOT} directory.
</html>
EOF
        chown -R "${UNIT_USER}":"${UNIT_GROUP}" "${UNIT_WEBROOT}"
    fi
}

unit_site_enable() {
    if [ -n "${1}" ]; then
        if [ "${1,,}" = "all" ] ; then
            if [ "$(ls -A /etc/unit/sites.available/)" ]; then
                shopt -s nullglob
                for site in /etc/unit/sites.available/*.json; do
                    print_debug "Enabling Unit Site '$(basename "${site}")'"
                    ln -sf /etc/unit/sites.available/"$(basename "${site}")" /etc/unit/sites.enabled/
                done
                shopt -u nullglob
            fi
        else
            if [ -f "/etc/unit/sites.available/${1}.conf" ]; then
                print_debug "Enabling Unit Site '${1}.json'"
                ln -sf /etc/nginx/unit.available/"${1}".json /etc/unit/sites.enabled
            else
                print_error "Cannot enable site ${1} as it doesn't exist in /etc/unit/sites.available!"
                exit 1
            fi
        fi
    else
        print_error "Need json configuration file as argument to utilize 'unit_site_enable' function"
    fi
}

unit_site_disable() {
    if [ -n "${1}" ]; then
        if [ "${1,,}" = "all" ] ; then
            shopt -s nullglob
            for site in /etc/unit/sites.enabled/*.json; do
                print_debug "Disabling Unit Site '$(basename "${site}")"
                rm -rf /etc/unit/sites.enabled/"$(basename "${site}")"
            done
            shopt -u nullglob
        else
            if [ -f "/etc/unit/sites.enabled/${1}.json" ]; then
                print_debug "Disabling Unit Site '${1}.json'"
                rm -rf /etc/unit/sites.enabled/"${1}"*
            else
                print_error "Cannot disable site ${1} as it doesn't exist in /etc/unit/sites.enabled!"
                exit 1
            fi
        fi
    else
        print_error "Need configuration file as argument to utilize 'unit_site_disable' function"
    fi
}

unit_post_init() {
    set -x
    if var_true "${UNIT_ENABLE_APPLICATION_CONFIGURATION}" ; then
        if [ -n "${UNIT_SITE_ENABLED}" ] ; then
            if [ "${UNIT_SITE_ENABLED,,}" != "null" ] ; then
                sites=$(echo "${UNIT_SITE_ENABLED}" | tr "," "\n")
                for site in $sites; do
                    unit_site_enable "${site}"
                done
            fi
        else
            unit_site_enable all
        fi
    fi

    if [ -n "${UNIT_POST_INIT_SCRIPT}" ] ; then
        print_debug "Found Unit Post Init Scripts"
        post_scripts=$(echo "${UNIT_POST_INIT_SCRIPT}" | tr "," "\n")
        for post_script in $post_scripts; do
            if [ -f "${post_script}" ] ; then
                print_debug "Executing post init script '${post_script}'"
                chmod +x "${post_script}"
                "${post_script}"
            else
                print_error "Tried to run post script '${post_script}' but it does not exist!"
            fi
        done
    fi

    if [ -n "${UNIT_POST_INIT_COMMAND}" ] ; then
        print_debug "Found Post Init Command"
        post_commands=$(echo "${UNIT_POST_INIT_COMMAND}" | tr "," "\n")
        for post_command in $post_commands ; do
            print_debug "Executing post init command '${post_command}'"
            "${post_command}"
    	done
    fi

    mkdir -p "${UNIT_WEBROOT}"
    if var_true "${UNIT_FORCE_RESET_PERMISSIONS}" ; then
        chown -R "${UNIT_USER}":"${UNIT_GROUP}" "${UNIT_WEBROOT}"
    fi

    cat <<EOF >> /root/.bashrc

    unit_import() {
        curl -X PUT --data-binary @\${1} --unix-socket "${_unit_control}" http://localhost/config
    }
EOF
set +x
}
